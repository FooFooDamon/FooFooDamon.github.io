<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<base target="_blank" />

# I2C协议摘要

[协议原始文档](references/spec/I2C_Spec.pdf)

## 1、简介

略。

## 2、特性

* 仅需`2`条线：`SCL`、`SDA`。

* 支持简单寻址。

* 当多个设备同时发送数据时，可自行进行冲突检测和总线仲裁。

* 连接到总线的设备数量只受限于`最大总线电容值`（注：
若考虑到现实业务场景，通常也受限于`7`比特长度的地址范围）。

* 器件易替换、易升级，仅需将旧版本的器件拆下（`Unclip`），
再将新版本的器件挂接（`Clip`）上去即可（待确认：是否等同于热插拔）。

* 其余特性的描述详见原文档。

## 3、协议明细

* `SCL`和`SDA`的基本要求：
    * 支持双向传输，但只能**半双工**。
    * 多设备场景下应在两条总线上分别接一个**上拉**电阻，
    设备的输出应为`开漏`或`开集`结构，以便能执行“**线与**”逻辑。
    对于单设备场景，由于没有总线竞争，还可以采取`推挽`输出。
    * 由“**线与**”逻辑可知`0`对应`低`电平、`1`对应`高`电平，但由于`CMOS`、`NMOS`、
    双极晶体管等类型对高/低电平的要求并不一样，所以高/低电平的阈值并不固定，
    而是根据V`dd`而定，分别为**0.7**V`dd`和**0.3**V`dd`。
    * `SCL`对`SDA`的约束：
        * 在`SCL`为**高**电平期间才能对数据采样，此期间`SDA`**状态必须保持稳定**，
        否则可能误判为`开始`或`停止`信号，详见后文。
        * 只有`SCL`为**低**电平期间，`SDA`才允许**变化**。
        * `1`个**时钟周期**对应`1`个**数据比特**。

* `开始`（后文记为`START`）和`停止`（后文记为`STOP`）信号：
    * `SCL`**高**电平期间`SDA`的**下降沿**为`START`，总线处于**繁忙**（`busy`）状态。
    某些时候还允许重复的`START`。
    * `SCL`**高**电平期间`SDA`的**上升沿**为`STOP`，**一段特定的时间之后**，
    总线回到**空闲**（`free`）状态。
    * 若设备硬件不是边沿触发，则需要在一个时钟周期内对`SDA`至少采样`2`次才能察觉电平转变。
    * 波形图见`3.1.4`小节。

* 字节格式：
    * `1` Byte = `8` bits
    * 一次传输过程不对字节数进行限制。
    * **每个字节**后面必须**紧跟**一个**确认/否认**信号（见后文），
    所以**一个字节实际上占用`9`个时钟周期**。
    * 字节内的**比特传输顺序**是**从高到低**。
    * 如果一个设备由于进行某些操作（例如处理内部中断）而**不能继续接收或发送下一个字节**，
    则可以将**时钟线**`SCL`**拉低**（收发方均可操作），令**控制器**进入**等待状态**（`wait state`），
    直到再次就绪后再释放`SCL`。
    * 波形图见`3.1.5`小节。

* `确认`（`Acknowledge`，后文记为`ACK`）和`不确认`（`Not-Acknowledge`，后文记为`NACK`）信号：
    * 均是接收端对发送端的响应，即：接收端是主动方，发送端是被动方。
    * 在第`9`个时钟周期，先由**发送端**释放`SDA`（即**拉高**），
    再由**接收端**在`SCL`**低电平**期间将`SDA`**拉低**或`不对其操作`（即`保持高电平`），
    并且`SCL`**高电平**期间**保持**`SDA`**该状态**，即可产生**ACK**或`NACK`。
    * 如果是`NACK`，则控制器接下来既可以发`STOP`来中止传输，也可发`START`来启动新一轮传输。

* 时钟同步（`Clock Synchronization`）：
    * 即在多设备场景下，每个设备根据所有时钟信号在`SCL`的综合结果来对自己的内部时钟进行调整，
    最终达到所有时钟的升降沿对齐到同一标准的效果。有`2`个重点：
        * 对“线与”逻辑的应用。
        * 硬件自动调节。
    * 波形图见`3.1.7`小节。

* `仲裁`（`Arbitration`）：
    * 当多个设备同时发送消息，需要一种机制来决定哪一个设备能记得总线（`SCL`和`SDA`）使用权，
    这就是仲裁。
    * 原理不难理解，以下仅强调几个重点：
        * 基于对“**线与**”逻辑的应用，所以发**0**者**获胜**。
        * 仲裁是**按位进行**的，所以地址或数据**较小者获胜**。
        * 仲裁落败的设备的待发消息不会丢失，会在获胜者发完一个字节（含`ACK`/`NACK`）
        或`STOP`后（待确认：`1`Byte还是一整轮，取决于具体实现？？）再次尝试——当然，
        要先重发`START`信号。
        * 落败者若还具有接收信息的需求，就需要切换成接收方，
        并检查获胜者的寻址对象是否是自己。
        * 仲裁期间若部分设备发`START`或`STOP`，结果将是**未定义**的，需要避免。
    * 波形图见`3.1.8`小节。

* 目标地址（`7`位）：
    * **紧跟在`START`信号之后**。
    * 高`7`位是实际地址，**最低位**是读写标志：`0`表示**写**，`1`表示**读**。
    * 虽然一轮完整的传输总是以`STOP`为结尾，但当同一设备要对多个目标（亦即涉及多个地址）收/发数据，
    在收/发完一个目标的数据后，可以省略该目标对应的`STOP`，直接发`START`来开始下一个目标的传输，
    直至收/发完最后一个目标的数据再发`STOP`。
    * 注意`读`/`写`操作对`ACK`/`NACK`的要求，尤其是读写混合的场景，示意图见`3.1.10`小节末尾。
    * 允许多个设备具有相同的地址，这种就类似于广播，但这些设备要根据具体业务自行控制好交互逻辑。
    * 注意几个预留地址：
        * `0000 000` && `R/W` = 0：用于`通用呼叫`（`General Call`），可进行复位、
        键盘扫描或设备自定义操作，详见`3.1.13`、`3.1.14`、`3.1.17`小节。
        * `1111 1XX`：设备身份标识（`Device ID`）。
        * `1111 0XX`：表明将使用`10`位地址。

* `10`位地址：
    * 在`7`位地址的基础上进行扩展，占用`2`个字节，其中`1`个字节使用预留地址`1111_0XX`。
    * 其余描述略。

* 以上内容适用于`超快速模式`（`Ultra Fast Mode`）以外的模式。
超快速模式有自己的协议规范，在以上内容的基础上有所不同，不继续展开，
感兴趣的可直接查阅原文档`3.2`小节。

## 4、I2C的若干变体

略。

## 5、不同的总线速率

* 双向模式（向下兼容）：
    * `Standard Mode`：标准模式，`<= 100 kbit/s`
    * `Fast Mode`：快速模式，`<= 400 kbit/s`
    * `Fast Mode Plus`：快速模式增强版，`<= 1 Mbit/s`
    * `High-speed Mode`：高速模式，`<= 3.4 Mbit/s`

* 单向模式（与前面不兼容）：
    * `Ultra Fast Mode`：超快速模式，`<= 5 Mbit/s`

* 除标准模式之外的其余四种模式的专属特性和时序，以及多种模式共享于同一物理总线上的注意事项，
不在此详述。

## 6、通信时序及相关的电气规范

略。

## 7、设备与总线的电气连接规范

略。

## 8、缩略词

* `I2C-bus`：`Inter-Integrated Circuit bus`，集成电路互连总线。

* 其余略。

## 9、`MIPI`-`I3C`概述

略。

