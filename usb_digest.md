<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<base target="_blank" />

# USB 2.0协议摘要

[协议原始文档](references/spec/USB2p0_Spec.pdf)

## 1、简介

* 动机：
    * 电脑与电话（`Telephone`）的互连（注：这是最初的设定，但后来已不限于这两种角色）
    * 易用性（`Ease-of-Use`）
    * 端口扩展（`Port Expansion`）

* 本文档内容的组织：
    * 第`1`至`5`章是面向所有读者的概述内容，第`6`至`11`章则是技术细节。
    * 外设开发者应着重阅读第`5`至`11`章。
    * `USB`主机控制器开发者应着重阅读第`5`至`8`章，以及第`10`、`11`章。
    * `USB`设备驱动开发者应着重阅读第`5`、`9`、`10`章。

* 其余内容略。

## 2、术语和缩略词

需要关注的有：

* `USB`：`Universal Serial Bus`，通用串行总线（注意其“通用”的设计理念），
是一种可热插拔、支持在电脑主机（实际上所有具备类似功能的设备均可）
和多种外部设备（后文简称`外设`）之间交换数据的总线，其通信方式的主要特点是：
由主机调度（`host-scheduled`）、基于令牌（`token-based`）、
挂载在同一主控上的所有外设共享该总线的带宽。

* `--------`

* `EOF`：`End-of-(micro)Frame`，（微）帧尾，与其相对应的是`SOF`——`Start-of-(micro)Frame`，
（微）帧头，在本章不再单独列出。

* `EOP`：`End-of-(micro)Packet`，（微）报文尾，与其相对应的是`SOP`——`Start-of-(micro)Packet`，
（微）报文头，在本章不再单独列出。

* `--------`

* `IRP`：`I/O Request Packet`，输入/输出请求报文，由客户端软件（应用层）发起，
传递到下层会转换成`Transfer`。

* `Transfer`：由单个或多个`事务`组成的一次**传输**过程。

* `Transaction`：**事务**，由`1`个**令牌**报文、`0`或`1`个**数据**报文、
`0`或`1`个**握手**报文（即`ACK`、`NAK`、`STALL`等状态响应）组成。
尤其注意**握手**报文，只有**支持流量控制**的传输类型的每个事务**才会有**，
所以**除了等时型**传输，其他类型传输的事务都会有握手报文。

* `Packet`：**报文**。注意它是更高一层的抽象——`事务`的组成单位。

* `--------`

* `Frame`：用于低速、全速总线的`时基`（`Time Base`，基本时间片段），其时长为`1ms`。

* `Microframe`：用于高速总线的`时基`，其时长为`125us`。

* `--------`

* `Endpoint`：端点。一个`USB`设备（注意不是主机）可包含多个端点，
每个端点具有一个在设备**内部唯一**的**地址**，而每个地址则由端点**号**和传输**方向**组成，
注意将流入主机的方向定义为`IN`、从主机流出的方向（即流向设备）定义为`OUT`。

* `Function`：功能单元、功能实体，即具有特定功能的`USB`设备，
例如键盘、鼠标、打印机、扫描仪、摄像头等。后文简记为`func`。

* `Host Controller`：主机控制器（后文会简称为`主控`或`HC`），是主机的总线（**硬件**）接口。

* `HCD`：`Host Controller Driver`，主控驱动程序，是一个**软件**概念，位于`USBD`的下面，
是系统软件（位于`驱动层`）和`HC`（位于`链路层`）之间的接口，**真正接触硬件细节**。
注意：由于`HCD`屏蔽了硬件的复杂性并提供统一接口，所以一个`USBD`可以同时支持多种`HCD`，
但对于一个具体主机，由于`HC`是确定不变的，因此主机厂商只需提供一种`HCD`。

* `Hub`：集线器，一种用于扩充连接口的设备。

* `USBD`：`USB Driver`，总线驱动程序，位于客户端软件的下面、`HCD`的上面，
且与`HCD`一同位于`设备层`（即**驱动层**）。从第`5.3`节的通信层级关系图可以看出，
`USBD`实际上充当着客户端操纵**对侧**同层的`func`和**同侧**下层的`HC`（需要经过`HCD`）的代理。

## 3、背景

* 目标（`Goals`）：略。

* 速率等级：
    * 低速（`Low-Speed`）：`10 - 100kb/s`，主要用于键盘、鼠标等。
    * 全速（`Full-Speed`）：`500kb/s`～`12Mb/s`，可用于音频、话筒等。
    * 高速（`High-Speed`）：`25-480Mb/s`，可用于大容量储存设备、图像传输等。

* 特性列表：略。

## 4、架构概述

* 系统描述：
    * 互连标准：
        * 总线拓扑：注意在层数方面最多支持`7`层，最顶层必须是主机上的`根源集线器`（`Root Hub`），
        最底层必须是`功能体`（`func`）。
        * 各个通信抽象层的功能及联系。
        * 数据流程模型：对于不同层级、不同粒度的数据载体的抽象，以及对于时序、
        格式/结构的规定。
        * 调度策略：处理总线复用、时间片划分、带宽分配等问题。
    * 设备：包括`hub`和`func`，但复合设备可同时集成这两种。技术框架详见第`9`章，
    `hub`还会有额外的第`11`章来详细介绍其独特的技术规范。
    * 主机：通信操作的主导者，默认的供电者，有且只能有`1`个。技术规范详见第`10`章。

* 物理接口：
    * 电气特性：
        * 电源：
            * V`bus`、`GND`
        * 数据：
            * `D+`、`D-`（即**差分**信号）
            * 采用`NRZI`（`Non-Return-to-Zero Inverted`）编码和位填充（`Bit Stuffing`），
            接收端可凭此还原出时钟信号，所以不需要时钟线
    * 机械工艺：略。

* 电源：
    * 供电：可通过总线供电，也可以设备自供电。
    * 电源管理：研究如何让系统更省电，常见的与电源有关的事件有挂起、恢复等。
    除了主机提供的策略，设备也可以自己实现额外的策略。

* 总线协议：
    * `USB`是一种**轮询**型总线，且由主机主导，目的是为了防止多个设备争抢总线，
    以及避免由此带来的复杂仲裁机制。
    * **多数**事务最多有`3`个报文：
        * **令牌**报文用于**询问**。
        * **数据**报文（可空）。
        * **握手**报文用于汇报状态（`ACK`、`NAK`、`STALL`等）。注意**等时型事务无握手报文**。
    * 若是主机与`hub`之间的通信，则最多涉及`4`个报文，因为需要进行速率匹配、转换等。
    * **管道**：
        * **主机**（缓冲区）与某个设备**端点**的**传输路径**就是一条管道。
        * 管道参数包括：带宽、传输类型（即后文的`Transfer Type`）、端点属性（例如传输方向、
        缓冲区大小等）。注意：**一条管道可被同一个编号、同一种传输类型、方向相反的两个端点共享**。
        * 有`2`种类型：
            * **消息**管道（`Message Pipe`）：传输**有**特定**结构**的数据（只要求数据遵循特定规范，
            但`USB`并不解析内容），且在设备接上之时就配备一条`默认控制管道`（`Default Control Pipe`）。
            * **流式**管道（`Stream Pipe`）：需要手动创建，传输**无结构**的数据。

* 健壮性：
    * 通过差分信号、物理屏蔽层来保障信号完整性（`Signal Integrity`）。
    * 使用`CRC`校验机制来保护控制域和数据域字段。
    * 超时控制、重试。
    * 流量控制。
    * 资源配额、管道隔离。

* 系统配置：
    * 热插拔
    * 总线枚举

* **传输类型**：
    * **控制**型传输（`Control Transfer`）：
        * 用于挂载期的配置，包括对于其他管道的控制；
        * 或设备自定义逻辑。
    * **批量**型传输（`Bulk Data Transfer`）：
        * **数据量较大**，时机方面也有**突发性**，例子有打印机、扫描仪、`U`盘等。
        * 有硬件级别的纠错（`CRC`）和重试机制。
        * **对带宽的利用很灵活**，**允许较大的延迟**，可以利用带宽空闲区。
    * **中断**型传输（`Interrupt Data Transfer`）：
        * 实际上还是依靠主机**轮询**，常用于键盘、鼠标等交互式设备。
        * 设备需要**在一定的时间范围**内作出**响应**。
        * 注意：**数据**是**随机**产生的（无数据也需要给出响应），但主机的**轮询**却是**定期**的。
    * **等时**型传输（`Isochronous Data Transfer`）：
        * **预先协商**好**带宽**和**最大延迟**以确保传输的**实时性**，
        所以这种方式也叫`流式实时传输`（`Streaming Real Time transfer`）。
        * 传输**速率**必须**恒定**才能确保数据之间的时间关系不破坏。
        * 由于要保证实时性，所以**无重试**，**允许丢包**。
        * 应用场景多见于音视频，但却不限于此，也不要求业务一定是实时的。
    * 注意：
        * `控制型`传输走的是`消息`管道，**其余类型**的传输走的是**流式**管道。
        * 批量型传输与等时型传输的共同点是数据量较大，不同点是传输是否具有周期性、
        可靠性，以及对带宽和响应延迟的要求。
        * 中断型传输与等时型传输的共同点是对时间有要求（即周期性、响应延迟等），不同点是数据量。

* `USB`设备：
    * 特征（`Characterization`）：有标准（`Standard`）配置（详见第`9`章）、类别（`Class`）、
    厂商（`Vendor`）信息等。
    * 分类：`hub`和`func`
    * 详细介绍略。

* `USB`主机：略。

## 5、数据流程模型（必读）

* 实现者眼中的`USB`：主要有`4`个关注点，划分成`2`侧如下所示：
    * 设备侧：
        * 物理设备：一般看成一个整体。
    * 主机侧：
        * 客户端软件：位于`功能层`（`Function Layer`，相当于**应用层**），专注于**具体**的**策略**。
        * 系统软件：位于`设备层`（`USB Device Layer`，可理解为**驱动层**），专注于**通用**的**机制**，
        由`USBD`、`HCD`（主机控制器的软件部分）等构成。
        * 主机控制器：即`HC`，主要作为一个硬件概念来使用，位于`总线接口层`
        （`USB Bus Interface Layer`，相当于**链路层**）。

* 总线拓扑：
    * 主机及设备：
        * 主机（详见第`10`章）的逻辑构成从上到下可分为`3`部分，在上一小节已介绍。
        * 设备（详见第`9`章）的逻辑构成从上到下也分为`3`部分：
            * `func`。
            * 逻辑设备：注意不同的物理设备有不同的功能，但逻辑设备却着重于向主机提供通用的基础接口。
            * 总线接口。
    * 物理拓扑：
        * 连接形式为**分层**的**星形**结构（实际上与树形结构无异），
        注意采用分层的目的是为了防止环形挂载。
        * 由`hub`来提供`挂载点`（`Attachment Point`，也叫`端口`，即`Port`）让设备接入，
        每个`hub`有一个或多个端口。注意主机内置了一个位于最顶层的`Root Hub`，
        复合设备（`Compound Device`）内部也有一个`hub`。
        * 每个`hub`和`func`都有一个唯一地址，而且从主机视角来看，
        一个复合设备也当作一个`hub`和若干个`func`来处理。
        * `hub`在高速总线系统中扮演着一个特殊的角色，就是将低速/全速信号环境与高速信号环境隔离开来，
        但注意高速`hub`可接一个低速/全速`hub`，却不能接低速/全速设备，不过`HC`却能直接低速/全速设备。
        * 每个`HC`最多接`127`个设备。
    * 逻辑拓扑：
        * 在物理拓扑基础上，省略中间节点（即`hub`），简化关系图，只有主机与各个`func`直连。
        * 但主机的内部仍需意识到`hub`的存在，以便在移除`hub`的同时也能移除接在该`hub`的所有`func`。
    * 客户端软件与`func`的关系：
        * 虽然逻辑上可认为两者在同一层级上直接相连，
        * 但实际编程上应调用封装过的`API`，避免接触底层细节（例如访问特定内存区域或`IO`）。

* 通信流程：
    * 若干抽象关系：
        * 设备侧功能层：`Func` = `Interface` * `n`
        * 设备侧设备层：`Logical_Device` = `Endpoint` * `n` = （功能层的）`Interface`
    * **端点**（`Endpoint`）：
        * 每个**逻辑设备**均有一个在**挂载期间**由**系统**动态分派的**唯一地址**。
        * 每个逻辑设备包含多个端点，每个**端点**均在**设计之初**就分配一个固定的**内部唯一端口号**
        和方向（意味着每个端点都是`单工`通信）。
        * 靠`(device-address, endpoint-number, direction)`三元组可唯一确定一个端点。
        * 除了端口号和方向，端点还需要具备以下参数：频率/延迟要求、带宽要求、错误处理的行为要求、
        **报文的大小**限制、**传输类型**。
        * `0`号端点（`2`个：`1`个`IN`，`1`个`OUT`）：
            * 需要强制支持，在上电或复位时就已处于可用状态。
            * 连接一条`默认控制管道`（`Default Control Pipe`），用来进行一些基础、通用的信息配置、
            状态设置。
            * 至少应支持`set_{addr,config}()`、`get_descriptor()`请求。
        * 非`0`号端点（可选）：
            * 低速`func`最多只能有`2`个（`IN`还是`OUT`未明确），
            全速`func`最多只能有`IN`和`OUT`各`15`个。
            * 在使用`0`号端点未对`func`进行正确配置之前，所有非`0`号端点均不可用（但已存在）。
    * **管道**（`Pipe`）：
        * 在前面第`4`章已有所介绍，此处为补充内容。
        * `默认控制管道`：见前面对于`端点`的说明。
        * 非默认管道：非`0`号端点所使用的管道，生命周期亦与所属端点相同。
        * `IRP`（`I/O Request Packet`）：
            * 由客户端发起，具体形式因操作系统而异（类似`send()`、`recv()`、`poll()`等）。
            * 当一个`IRP`所关联的事务传输完成或出错时，客户端会收到通知，
            但等时型传输和非等时型传输对于错误的处理会有区别，详见后面章节。
            * 一个`IRP`可以把客户端数据拆分成多个载荷进行发送，除了最后一个之外，
            **前面的载荷**均要**填充**至**最大报文长度**。至于**最后一个载荷的长度要求**，
            要由**客户端指定处理方式**，即：**若**客户端**接受任意长度**的载荷，
            **则**最后一个载荷**不需填充**，**否则**当最后一个载荷**长度不够时**会**视为错误**。
            * **端点**可使用`NAK`来告知主机目前它处于**繁忙**状态，所以`NAK`不是错误。
        * **流式**管道（单向）：
            * 通常一条管道只被一个客户端使用。
            * 若是多个客户端使用同一条管道，则无强制要求系统软件对被传输的数据进行同步，
            而是采用先入先出的顺序进行传输。
            * 支持**除控制型之外**的传输类型。
        * **消息**管道（双向）：
            * 传输的内容有**固定的模板**：`Request/Data/Status`
            * 不支持并发处理，一次只能发一条消息，发完当前消息或发送出错，
            才能发下一条（但后一个传输的`Setup`提前出现能中止前一个传输，这是需要避免的）。
            * 允许多个客户端同时使用`默认控制管道`，遵循先入先出的原则。
            * **仅**支持**控制型**传输。
    * 帧（`Frame`）、微帧（`Microframe`）：
        * 均是**时间片段**（前者是`1ms`，用于低速/全速总线；后者是`125us`，用于高速总线），
        而不是数据格式。
        * 一个帧/微帧内可传输若干个事务。
        * 等时型和中断型每隔`N`个帧/微帧就会获得使用总线的机会，对于`N`值的指定及其他细节，
        详见后文。

* 控制型传输（**双**向，走`消息`管道）：
    * 用于传输配置、命令、状态信息。
    * 固定的通信模板：
        ````
        Host                    Device
          |         Setup         |
          |---------------------->|
          |     IN Data (>= 0)    |
          |<----------------------|
          |           .           |
          |           .           |
          |           .           |
          |           or          |
          |     OUT Data (>= 0)   |
          |- - - - - - - - - - - >|
          |           .           |
          |           .           |
          |           .           |
          |         Status        |
          |<----------------------|
        ````
    * 数据格式：详见第`8.5.3`节和第`9`章。
    * 数据载荷最大长度（后文用`wMaxPacketSize`表示）：
        * 低速：`8`字节
        * 全速：`8`、`16`、`32`或`64`字节
        * 高速：`64`字节
        * 当最后一个载荷长度小于`wMaxPacketSize`时，不必填充，但前面的载荷长度必须是`wMaxPacketSize`。
        * `Setup`报文固定`8`字节。
        * `0`号端点（使用的是`默认控制管道`）的`wMaxPacketSize`可通过传送过来的`设备描述符`
        （`Device Descriptor`）的前`8`个字节获知。
        * 其他控制端点的`wMaxPacketSize`值要在初始化完成后才确定。
        * 数据传输完成的条件：
            * 传输的数据量正好等于`Setup`阶段（在`Data`报文）指定的字节数；
            * 或者报文的载荷长度小于`wMaxPacketSize`（包括`0`长度）。
        * 管道被关停（`abort`、`halt`或`retire`）的条件：
            * 数据传输完毕，但主控不进入`Status`阶段；
            * 或传输超量数据。
    * 总线访问限制：
        * 所有控制型传输都是`尽最大努力`（`best effort`）去实施，速率变动很大。
        * 比等时型和中断型传输的优先级低，不允许侵占这两者的总线时间，只能趁它们空闲时使用总线。
        * 比批量型传输的优先级高，只有当控制型传输使用的帧时长小于`10%`或微帧时长小于`20%`，
        剩余的时长才可被批量型传输使用。
        * 不同端点的控制型传输，采取公平的访问策略。
        * `OUT`方向的高速控制端点必须支持`PING`协议，详见第`8.5.1`节。
        * 每一帧允许的最大传输次数举例（载荷长度不同，次数也不同，详见第`5.5.4`节的表格）：
            * 低速：< `8`Bytes * `4`
            * 全速：< `8`Bytes * `29`
            * 高速：< `64`Bytes * `32`
        * **待理解**：`10%`的低速/全速帧预留和`20%`的高速微帧预留。可能原文表述有问题。
    * 异常情况处理：
        * 在`Data`和`Status`报文期间，端点处于繁忙状态，主机应在稍后进行重试。
        * 后一个传输的`Setup`提前出现能中止前一个传输，这是需要避免的。
        * 有错误检测、恢复/重发的机制，但只有`Data`和`Status`报文能分辨是原报文或是重发报文，
        `Setup`报文则无法分辨。

* 等时型传输（定速、保带宽、限延迟；仅限全速和高速；单向）：
    * 数据格式：无。
    * 数据载荷最大长度：
        * 全速：`1023`字节
        * 高速：`1024`字节
        * 每个（不限于最后一个）事务的数据载荷长度可以小于`wMaxPacketSize`，
        由发送端决定——发送端发多少字节（只要不超过`wMaxPacketSize`），
        总线就传输多少字节，注意总线错误可能会导致部分字节遗失，
        但接收端可通过数据载荷的`CRC`或接收端内部逻辑来发现错误，
        详见第`5.12`节（`有关等时传输的特殊考虑`）。
        * 所有设备的默认`接口设置`都不准包含`wMaxPacketSize`为`0`的等时型端点，
        若需要更大的`wMaxPacketSize`，可另行指定`配置`或`接口设置`并将该字段设成非`0`值。
    * 总线访问限制：
        * 全速端点不能占用超过`90%`的帧时长，高速端点不能超过`80%`。
        * 端点需明确指定所需的总线访问周期：`F * 2^(bInterval - 1)`，
        其中F为`1ms`（全速）或`125us`（高速），`bInterval`的范围为`[1, 16]`，
        有若干点需要说明：
            * 由公式可知，允许以较慢速度进行传输（即多个帧或微帧才传输一个事务）。
            * 除非是高速高带宽端点（此时`F`=`1`，且每个周期传输字节数大于`1024`，
            每微帧也不止一个事务，更详细的描述见第`5.9.2`小节），否则每帧或微帧的事务数量不能超过`1`。
            * 当主机轮询（即`IN`方向传输）时间间隔小于该周期，端点必须返回一个`0`长度报文。
        * 每一帧允许的最大传输次数举例（载荷长度不同，次数也不同，详见第`5.6.3`节的表格）：
            * 全速：< `256`Bytes * `6`
            * 高速：< `1024`Bytes * `8`
    * 异常情况处理：
        * 无握手报文，也不支持重发。
        * 更注重实时性，而非可靠性，所以允许丢包，出现错误时也会继续后面数据的传输，
        即**不会因为错误而导致停机**（`halt`），除非是由于需要省电等原因而主动停机。

* 中断型传输（不频繁但要求迅速响应；单向）：
    * 数据格式：无。
    * 数据载荷最大长度：
        * 低速：`8`字节
        * 全速：`64`字节
        * 高速：`1024`字节
        * 当最后一个载荷长度小于`wMaxPacketSize`时，不必填充，但前面的载荷长度必须是`wMaxPacketSize`。
        * 所有`高速`设备的默认`接口设置`都不准包含`wMaxPacketSize`大于`64`的中断型端点，
        若需要更大的`wMaxPacketSize`，可另行指定`配置`或`接口设置`并将该字段设成更大值。
        * 数据传输完成的条件：
            * 传输的数据量正好等于指定的字节数；
            * 或者报文的载荷长度小于`wMaxPacketSize`（包括`0`长度）。
        * 传输完成后，主控会继续处理下一个`IRP`。
        * 管道被关停（`abort`、`halt`或`retire`）的条件：
            * 传输超量数据。
    * 总线访问限制：
        * 低速/全速端点不能占用超过`90%`的帧时长，高速端点不能超过`80%`。
        * 每一帧允许的最大传输次数举例（载荷长度不同，次数也不同，详见第`5.7.4`节的表格）：
            * 低速：< `8`Bytes * `7`
            * 全速：< `64`Bytes * `20`
            * 高速：< `1024`Bytes * `7`
        * 端点需明确指定所需的总线访问周期：
            * 低速：`10`～`255` ms
            * 全速：`1`～`255` ms
            * 高速：`125us * 2^(bInterval - 1)`，其中`bInterval`的范围为`[1, 16]`。
            高速高带宽端点的情况也与等时型传输类似，详见第`5.9.1`小节。
            * 注意：系统提供的实际周期可能短于理论值，
            主控也会确保两个事务发起的时间点间隔不会大于一个理论周期，
            但有错误发生时除外。
        * 如果客户端没有待处理的`IRP`，就不会轮询端点，即使总线时间点到了或端点有数据。
        一旦有可用的 `IRP`，会安排在下一个周期传输数据。
        * 若端点无中断型数据，可回复`NAK`。
    * 异常情况处理：
        * `DATA0`、`DATA1`报文标识的切换问题，详见第`8`章。
        * 若有偶发性的错误导致要重试，则重试要安排在下一个周期。
        * 若传输出错或端点返回`STALL`握手包 导致管道停机（`halt`），
        需要通过一条独立的控制管道进行软件干预才能恢复。

* 批量型传输（较大数据量且灵活利用总线时间；仅限全速和高速；单向）：
    * 数据格式：无。
    * 数据载荷最大长度：
        * 全速：`8`、`16`、`32`或`64`字节
        * 高速：`512`字节
        * 当最后一个载荷长度小于`wMaxPacketSize`时，不必填充，但前面的载荷长度必须是`wMaxPacketSize`。
        * 数据传输完成的条件：
            * 传输的数据量正好等于指定的字节数；
            * 或者报文的载荷长度小于`wMaxPacketSize`（包括`0`长度）。
        * 传输完成后，主控会继续处理下一个`IRP`。
        * 管道被关停（`abort`、`halt`或`retire`）的条件：
            * 传输超量数据。
    * 总线访问限制：
        * 所有批量型传输都是`很努力`（`good effort`）地去实施，优先级最低（比控制型传输还低，
        速率变动更大，但有时候也能比控制型传输先行，取决于实际的主控策略和当时的总线利用情况）。
        * 仅在带宽较宽裕时才轮候得到。
        * 不同端点的批量型传输，采取公平的访问策略。
        * `OUT`方向的高速控制端点必须支持`PING`协议，详见第`8.5.1`节。
        * 偶发性错误会尝试重发；保证可靠性但不保证带宽和延迟。
        * 每一帧允许的最大传输次数举例（载荷长度不同，次数也不同，详见第`5.8.4`节的表格）：
            * 全速：< `64`Bytes * `20`
            * 高速：< `512`Bytes * `14`
    * 异常情况处理：
        * `DATA0`、`DATA1`报文标识的切换问题，详见第`8`章。
        * 若传输出错或端点返回`STALL`握手包 导致管道停机（`halt`），
        需要通过一条独立的控制管道进行软件干预才能恢复。

* 高速高带宽端点（仅限中断型和等时型传输）：
    * 在一个微帧内，一个该类型的端点可发起的事务数量可多达`3`个（普通端点的事务数量仅`1`个，
    还要注意端点上与总线上事务数量的区别），数据载荷大小高达`3072`字节。
    * 注意端点描述符（`Endpoint Descriptor`）`wMaxPacketSize`字段的内部组成。
    * 注意对于不同事务数量下`DATA0`～`DATA2`、`MDATA`报文标识的切换规则。
    * 其余细节详见第`5.9`节。

* 分离事务（`Split Transaction`）：
    * 用于`HC`和`hub`之间的通信，对于设备是不可见的。
    * 作用是令到全速和低速设备能接到高速`hub`。
    * 中断型和等时型的高速分离事务占用的是内容带宽，即最高`80%`的那部分。

* 总线访问（主机侧逻辑）：
    * 传输管理（向设备分配带宽的过程）：
        * 注意第`5.11.1`小节的示意图，记住`IRP`、`Transfer`、`Transaction`、`Packet`的互转关系，
        还有`Client Software`、`USBD`、`HCD`、`HC`的层级关系，以及它们的主要职责如下：
            * `Client Software`：
                * 调用`USBD`提供的接口来发出`IRP`，或通过回调函数（或特定缓冲区）来接收`IRP`结果。
            * `USBD`：
                * 利用`HCD`接口来对`IRP`和`Transfer`进行互转。
                * 参与设备的挂载（涉及接收配置、创建管道、分配带宽等）和移除。
                * 参与常规传输过程。
            * `HCD`：
                * 将`Transfer`转成`Transaction`并放入`Transaction List`投递给`HC`，
                或从`Transaction List`取出`Transaction`并转成`Transfer`向上传给`USBD`。
                * 控制带宽和帧的使用额度。
                * 操作与客户端相关的缓冲区。
            * `Transaction List`：
                * 是待收/发事务的暂存区。
                * 概念是通用的，但具体实现则取决于各厂商。
            * `HC`（硬件）：
                * 逐个取出`Transaction`并将其报文化为`Packet`，再转成物理电信号发送到总线，
                或将电信号还原成`Packet`，再组装成`Transaction`向上传给`HCD`（先放入暂存列表）。
                * 还能获知`Transaction`的状态，例如完成（`done`）、未决（`pending`）、
                中止（`halted`）等。
    * 事务追踪：
        * 解决`IRP`和`Transaction`的互转（合并/拆分、报文化）问题。
        * 决定收/发时机和事务间顺序：
            * 同一个`IRP`的`Transaction`不一定在同一帧，
            不同`IRP`的`Transaction`可能在同一帧。
            * 后到`IRP`的部分`Transaction`可能插队打散先到`IRP`，
            但同一`IRP`的各个`Transaction`的时间顺序一定不会乱。
        * 主要抽象关系：
            * `IRP` = `Transfer` * `n`
            * `Transfer` = `Transaction` * `n`
                * **Control** `Transfer` = `Setup(OUT)` + `Data(IN/OUT)` * `n` + `Status(IN)`
                * **Other** `Transfer` = `Data(IN/OUT)` * `n`
            * `Transaction` = `Token-Packet` * `1` + `Data-Packet` * `[0,1]` + `Handshake-Packet` * `[0,1]`
    * 总线时间的计算：
        * 与`wMaxPacketSize`、传输类型、传播延时等因素有关，不在此展开。
        * 计算公式见第`5.11.3`节。
    * 缓冲区大小：
        * 对于等时型管道，缓冲区长度通常是`1ms`或`125us`内能传输的数据量的`2`倍，
        更多细节详见第`5.12.4`小节。
        * 对于其他类型的管道，只要系统内存足够，应当容纳数量不限的事务。
    * 带宽回收：
        * 不同类型的传输优先级不同，能获知未用帧时间的方法也与实现相关，
        故无统一策略。

* 有关等时传输的特殊考虑：暂略。

## 6、机械封装

略。

## 7、电气特性

重点留意以下小节：

* `7.1.5`：设备速率识别（`Device Speed Identification`），通过在设备端的`D-`或`D+`线
接一个**上拉电阻**来让主机（在**设备插入时**）辨别是`低`速还是`全`速设备，
`高`速设备则在全速物理连接基础上加上**特定的复位协议**（详见第`7.1.7.5`小节）。

* `7.1.7`：信令电平（`Signaling Level`），定义了不同速率下最基础的`SE0`（单端信号`0`）、
`SE1`（单端信号`1`）、`Differential-0`（差分信号`0`）、`Differential-1`（差分信号`1`）、
`J`状态、`K`状态，以及基于它们的组合态（`Idle`、`Resume`等），
还定义了复位、挂起、恢复等信令流程。

* `7.1.8`：数据编解码（`Data Encoding/Decoding`），采用`NRZI`编码形式，
即以电平翻转表示`0`、不翻转表示`1`，而不是直接使用原始的差分`0`和差分`1`信号
（或基于它们的`J`、`K`态），再结合后面的`位填充`技术，
就可达到不需要专门的时钟线也能传输时钟信息的目的（注意：
`USB`是**同步**通信，而不是异步！）

* `7.1.9`：位填充（`Bit Stuffing`），当在发送端连续出现`6`个差分`1`，
就要插入一个差分`0`，再进行`NRZI`编码，而接收端则需要剔除填充的`0`比特。
位填充的目的是为了避免长时间的固定电平导致收发端时钟偏差越来越大。

* `7.1.10`：同步头（`SYNC`），在总线从空闲转向工作状态之前的一串`JK`序列。

* `7.1.13.2`：`EOP`宽度（`End-of-Packet` `Width`），
注意低/全速的`EOP`是由`SE0`和`J`状态组成，而高速的`EOP`则通过主动违反位填充规则而实现。

* `7.3`：物理层（`Physical Layer`），详细列举了各项电压、电流、电容、电阻、
时间等参数，以及通信波形的抖动、校正、延迟等指标的允许范围。

## 8、协议层（重点）

待补充。

## 9、`USB`设备框架（重点）

待补充。

## 10、`USB`主机的硬件和软件

待补充。

## 11、集线器规范

暂略。

