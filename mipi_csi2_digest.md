<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<base target="_blank" />

# MIPI CSI2 V1.2协议摘要

[协议原始文档](references/spec/MIPI_CSI-2_specification_v1-2.pdf)

## 1、概述

* 原内容略。

* 额外补充——`V1.x`的差异：
    * `V1.1`：支持**非连续时钟**，以及更高效的错误检测和纠正机制。
    * `V1.2`：引入了**虚拟通道**的概念，增加了对更复杂应用场景的支持，
    例如多摄像头配置和高速数据流管理。

## 2、术语

* 需关注的定义：
    * 虚拟通道（`Virtual Channel`）：本规范支持高达`4`个外设的多条独立数据流，
    每个外设的数据流（是否一个外设能有多条，此处指其中一条？）就是一条虚拟通道。
    这些数据流可互相交错，并以顺序报文的形式进行传输，且每个报文属于一个特定的外设或物理通道。

* 需关注的缩略词：
    * `BER`：`Bit Error Rate`，误码率。
    * `CCI`：`Camera Control Interface`，相机控制接口。
    * `CSI`：`Camera Serial Interface`，相机串行接口。
    * `DI`：`Data Identifier`，数据标识符。
    * `DT`：`Data Type`，数据类型。
    * `ECC`：`Error Correction Code`，纠错码。
    * `FE`：`Frame End`，帧尾。
    * `FS`：`Frame Start`，帧首。
    * `LE`：`Line End`，行尾。
    * `LS`：`Line Start`，行首。
    * `LLP`：`Low Level Protocol`，低级协议。
    * `PF`：`Packet Footer`，报文尾。
    * `PH`：`Packet Header`，报文头。
    * `PI`：`Packet Identifier`，报文标识符。
    * `PT`：`Packet Type`，报文类型。
    * `SLM`：`Sleep Mode`，休眠模式。

## 3、引用资料

略。

## 4、CSI-2概述

非常简单。略。

## 5、CSI-2各层定义

* 应用层：在更高的层次上对数据流进行编码和翻译，
主要是从像素值（`pixel values`）到字节（`bytes`）的映射。
这一层的产出是**像素**。

* 协议层：规定如何对**多条数据流**在**发送端**进行**标记**（`tagged`）和**交织**（`interleaved`），
以便在**接收端**能正确地**重构**（`reconstructed`）。该层又可细分为`3`个子层：
    * 像素与字节的互转（`Pixel/Byte Packing/Unpacking`）层：
        * **发送端**将（来自于应用层的）像素转成字节的操作叫**打包**。
        * **接收端**将（来自于`LLP`层的）字节转成像素的操作叫**解包**。
        * 根据不同的图像格式，像素的位数可从`6`位到`24`位不等。
        * 对于`8`位像素，实际上可省略打包和解包操作。
    * 低级协议（`Low Level Protocol`）层：
        * 对`SoT`和`EoT`之间的串行数据建立位级别和字节级别的**同步**。
        * **最小**数据**粒度**为**字节**。
        * 规定字节内部高低位的传输顺序。
        * 以**报文**的形式来组织数据。发送端会为数据加上报文头和（可选的）错误校验信息，
        接收端在提取数据时则需要剥离报文头，以及进行差错校验。
    * 通道管理（`Lane Management`）层：
        * **发送端**将数据**分发**到各个通道。
        * **接收端**将各个通道的数据**聚合**，并**重组**成原始数据流。

* 物理层：描述传输介质（电导体）的电气特性，以及信号的时序关系。
这一层既有字节级（`byte-level`）的同步机制（`synchronization mechanism`），
也有位级（`bit-level`）的同步机制。

## 6、相机控制接口（`CCI`）

* 基于`I2C`。要快速了解`I2C`，可参考[这篇文章](i2c_digest.md)。

* 在`CCI`总线，**接收端**作为**主机**（`Master`），**发送端**作为**从机**（`Slave`）——
这既与较新版的`I2C`协议文档淡化主从关系（已改用控制器、目标等名称）的描述不同，
也与物理层的同名术语毫无关系。

* `CCI`协议只是给出控制消息的**通用格式**，每款摄像头的消息内容由厂商自行定义。

* `CCI`比标准`I2C`多一个`子地址`（`sub address`），又叫`索引`——（`index`）。
`索引`可支持`8`位，也可支持`16`位，但**仍以字节为单位进行传输**。

* 至于数据，都是`8`位，但多个数据字节可合并成最终供上层使用的`16`位、`32`位等数据类型。

* （单字节寄存器的）读写时序：
    * 原文档将读操作分为`4`种，写操作分为`2`种，不利于记忆。
    * 由于**每次读写之后，索引均会自增一次**，再根据**是否指定`索引`**和**何时发`NACK`**，
    读操作可简化成`2`种，写操作可简化成只有`1`种，如下：
        * 从指定位置读取（即**随机读**）：
            * **需要**指定`索引`。
            * 共同前置时序为：<br>
            `START` -> `Slave Address` -> `0` -> `ACK` -> `Index` -> `ACK`<br>
            -> `Repeated START` -> `Slave Address` -> `1` -> `ACK`
            * 若只读`1`次就发`NACK`，则为原文档的`单次随机读`（`Single Read from Random Location`）；
            * 若读多次，除了最后一次发`NACK`，前面几次均发`ACK`，
            则为原文档的`随机顺次读`（`Sequential Read Starting from a Random Location`）。
            * 注意：一旦发`NACK`，紧接着就应发`STOP`来结束操作，这是`I2C`协议的基本要求，下同。
        * 从**当前**位置**读取**：
            * **不**需要指定`索引`。
            * 共同前置时序为（比随机读要简化好多，相当于从`Repeated START`开始）：<br>
            `START` -> `Slave Address` -> `1` -> `ACK`
            * 若只读`1`次就发`NACK`，则为原文档的`从当前位置读一次`（`Single Read from the Current Location`）；
            * 若读多次，除了最后一次发`NACK`，前面几次均发`ACK`，
            则为原文档的`从当前位置顺次读`（`Sequential Read Starting from the  Current Location`）。
        * 从指定位置写入（即**随机写**）：
            * **需要**指定`索引`。
            * 共同前置时序为：<br>
            `START` -> `Slave Address` -> `0` -> `ACK` -> `Index` -> `ACK`
            * 若只写`1`次就发`ACK`/`NACK`和`STOP`，则为原文档的`单次随机写`（`Single Write to a Random Location`）；
            * 若写多次才发`STOP`（最后一次既可发`ACK`也可发`NACK`，前面几次均发`ACK`），
            则为原文档的`顺次写`（`Sequential Write`）。
    * 不支持从当前位置写入的操作，因为写操作是一种破坏性操作，最好要明确指定位置，
    否则依赖于早前读写操作自增到达的位置并不保险，因为某些操作可能引起复位。

* 从机（即摄像头）地址：
    * 仅支持`Raw Bayer`格式的设备：`0x36`或`0x37`
    * 其他设备：`0x3C`或`0x3D`
    * 需要指出的是，尽管`CCI`规范对从机地址有以上规定，但实际上不少摄像头的地址支持定制，
    不过默认值通常按规范来设置。

* 多字节寄存器：
    * **多字节寄存器地址应是第`1`个字节的地址**，所以相邻两个寄存器的地址并不连续。
    * 虽然多字节寄存器位宽有`16`、`32`、`64`位之分，
    但使用的索引宽度和每次传输的数据宽度仍与前面单字节寄存器的一样。
    * **高字节位于低地址，低字节位于高地址**——所以**会先传输高字节**。
    * 第一个字节的地址是否与寄存器宽度对齐（类似于`C`语言的结构体内部字段对齐），取决于实现。
    * **不允许**只访问多字节寄存器的**部分字节**。
    * 对多字节寄存器的访问时序类似于单字节寄存器的`随机顺次读/写`时序，
    且接受数据的一方（不论主从）应该知道何时应发`NACK`，但有几点需要强调：
        * 对于写操作，是先写到临时缓冲区，要等到最后一个字节的最后一位传输完，
        才能更新寄存器内容。
        * 对于读操作，在读取第一个字节的第一位时，所有字节的内容就应该反映到临时缓冲区，
        然后再逐位传输到`SDA`线。
        * 以上涉及到临时缓冲区的描述，仅作为一种实现方案来举例，目的是更好解释读写一致性的行为和现象。
        对于临时缓冲区的更新和清零条件，详见`6.3.3.1`
        * `6.3`小节的所有图都应该加上寄存器地址（即首字节的索引值），
        并且最后一个字节跟的是`NACK`而非`ACK`。

## 7、物理层（`PHY`）

* 原文只是对物理层的一些核心要求进行列举。对于详细的`D-PHY`规范，
[这篇文章](mipi_d-phy_digest.md)可以作为一个阅读指引，至于`C-PHY`暂时不涉及。

* 原文还重点提到收发端对于**时滞校准**（`Deskew Calibration`）的一些设计要求，
尤其是建议周期性校准操作最好放到竖直消隐期或帧空隙。

## 8、重点：多通道的数据分发和聚合（通道管理层）

* 适用于想要**更高带宽**或想要**避免高时钟速率**（以降低电磁兼容性问题）的应用。

* 设计理念很简单，对于应用开发者而言，只要理解该理念，剩下的工作就是通过`CCI`配置好相关寄存器，
实际的数据分发和聚合工作就可交由硬件自动完成。通道管理层的**核心理念**有`2`个：
    * **缓冲**：一次最多缓冲`N`字节，其中`N`为启用的通道数。
    * **负载均衡**：采取**公平轮流**（`round-robin`）的策略进行分发。

* 发送端的逻辑结构（从上至下）：
    * 来自高层（即`LLP`层）的字节流
    * 通道**分发**功能单元（`Lane Distribution Function`，含缓冲器，即`buffer`）
    * （每条通道的 ）发送队列
    * **序列化**功能单元（`Serializer`，统一表示成`SerDes`）

* 接收端的逻辑结构（从下至上）：
    * **反序列化**功能单元（`Deserializer`，统一表示成`SerDes`）
    * （每条通道的）接收队列
    * 通道**聚合**功能单元（`Lane Merging Function`，含缓冲器，即`buffer`）
    * 投递给高层（即`LLP`层）的字节流

* 每条通道的收发时序（此处已属于物理层功能）：`LPS` -> `SoT` -> `Bytes` ... -> `EoT` -> `LPS`

## 9、重点：低级协议（`LLP`）

* 特性概述：
    * 能传输任意形式的数据，即**不关心有效载荷的格式**。
    * **面向字节**（`byte orientated`），**基于报文**（`packet based`）。
    * 同一链路上（即物理通道）最多支持`4`条虚拟通道交织（`interleaved`）。
    * 帧首、帧尾、行首、行尾信息有相应的特殊报文。
    * 定义了各种报文类型、像素深度和特定应用载荷数据格式的标识值。
    * 设置`16`位校验码用于错误检测。

* 报文格式（指位于`LPS`和`SoT`之后、`EoT`和`LPS`之前的内容）：
    * **长**包格式（`Long Packet Format`）：
        * `PH`：报文头，`32`位。构成如下：
            * `8`位`DI`（`数据标识符`）：
                * `VC`：虚拟通道，高`2`位，所以最多支持`4`条通道。
                * `DT`：数据类型，低`6`位，所以总共有`64`个类型，并且：
                    * 分为`8`个大类。其中前`2`个大类用于短包，后`6`个用于长包。
                    * 每个大类又细分为`8`个具体类型。
                    * 详细内容见`9.4`、`9.8`小节和第`11`章。
            * `16`位`Word Count`（`字数`）：
                * 实际上是`Payload`的**字节数**，因为此处使用的是`8`位字（`8`-bit words）。
                * 字节顺序：**先传低字节**，再传高字节。如无特殊说明，其他字段亦是如此。
                * 字节内的位顺序：**先传低位**，再传高位。如无特殊说明，其他字段亦是如此。
            * `8`位`ECC`（`纠错码`）：
                * 对于`PH`除`ECC`自身的其他字段，能**检测**出发生在他们身上的`2比特错误`（`2-bit errors`），
                以及修正`单比特错误`（`single-bit errors`）。
                * 原理详见`9.5`节。
        * `Payload`：
            * 有效载荷字节流，长度不固定，但通常上层应用会对长度有所要求，
            例如是`4`的整数倍字节。
            * 由于是**字节流**，所以**字节之间的顺序**在**上一层**就应该**先定好**。
            * 接收方不需要检查任何同步信号，仅需按预设的`Word Count`接收足够数量的字节即可，
            所以此阶段可简化接收逻辑，并且不必关心具体的字节值。
        * `PF`：报文尾，`16`位。构成如下：
            * `16`位`Checksum`（`校验和`）：其生成原理详见`9.6`节。
    * **短**包格式（`Short Packet Format`）：
        * `PH`：与长包的`PH`一样的结构，但内部字段的含义和取值不尽相同，以下仅列出不同之处：
            * `16`位百变字段：位置与长包的`Word Count`字段一样，但根据`DT`的不同，
            可存放帧编号（帧同步是必需的）、行编号（行同步是可选的）或用户自定义内容。

* 报文间隙（指前一报文的`EoT`、空闲期`LPS`和当前报文`SoT`的总时长）：
    * **长度不固定**。
    * 详见`9.7`、`9.10`小节。

* 图像帧格式：
    * 简单说明见`9.11`、`9.12`小节。
    * 详细说明见第`11`章。

* 数据交织（`Data Interleaving`）：
    * 按数据类型：见`9.13.1`小节。
    * 按虚拟通道：见`9.13.2`小节。

## 10、色彩空间

* `RGB`：采用`IEC 61966`标准的`sRGB`色彩模型。

* `YUV`：采用`ITU-R BT601.4`标准的`YCbCr`色彩模型。

## 11、数据格式

* 可分为`YUV`、`RGB`、`Raw`和用户自定义格式，详情可查阅原文档，不在此展开。

## 12、推荐的内存储存格式

* 主要是对传输的字节序、数据字节与内存地址的对应关系的设计建议，并与前一章有联系。详情略。

## 附录`A`：`JPEG8`数据格式（信息拓展）

略。

## 附录`B`：`CSI-2`实现方案举例（信息拓展）

略。

## 附录`C`：`CSI-2`接收端所推荐的错误处理行为（信息拓展）

对于调试工作有参考意义，可按需查阅。详情略。

## 附录`D`：`CSI-2`睡眠模式（信息拓展）

略。

## 附录`E`：用于原始数据类型的压缩方案（信息拓展）

略。

## 附录`F`：`JPEG`数据与其他类型数据的交织（信息拓展）

略。

